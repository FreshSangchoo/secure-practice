<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ElastiCache - AWS 기초 강의</title>
  <link href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css">
</head>
<body>

<header class="site-header">
  <div class="header-inner">
    <a href="../index.html" class="header-logo">
      <span class="aws-icon">AWS</span>
      <span>기초 강의</span>
    </a>
  </div>
</header>

<div class="page-layout">
  <nav class="sidebar">
    <ul class="sidebar-nav">
      <li class="sidebar-section">ElastiCache</li>
      <li><a href="#cache-concept">캐시란?</a></li>
      <li><a href="#redis-vs-memcached">Redis vs Memcached</a></li>
      <li><a href="#redis-use-cases">Redis 활용 사례</a></li>
      <li><a href="#cluster-config">클러스터 구성</a></li>
      <li><a href="#lab">실습</a></li>
    </ul>
  </nav>

  <main class="main-content">
    <div class="chapter-header">
      <span class="chapter-num">Chapter 24</span>
      <h1>ElastiCache</h1>
      <div class="objectives">
        <h3>학습 목표</h3>
        <ul>
          <li>캐시의 개념과 필요성을 이해한다</li>
          <li>ElastiCache에서 Redis와 Memcached의 차이를 비교할 수 있다</li>
          <li>Redis의 주요 활용 사례(세션 스토어, API 캐싱, 순위표)를 설명할 수 있다</li>
          <li>ElastiCache Redis 클러스터를 생성하고 EC2에서 접속할 수 있다</li>
          <li>ShopEasy API 서버에 Redis 캐싱을 적용하여 응답 속도를 개선할 수 있다</li>
        </ul>
      </div>
    </div>

    <!-- Section 1: 캐시란? -->
    <section class="content-section" id="cache-concept">
      <h2>캐시란?</h2>

      <div class="info-box analogy">
        <div class="info-box-title">비유: 냉장고</div>
        <p>매번 식사할 때마다 마트에 가서 재료를 사오면 시간이 많이 걸리죠? 그래서 <strong>자주 사용하는 재료를 냉장고에 보관</strong>합니다. 필요할 때 냉장고에서 바로 꺼내면 빠르고 편합니다.</p>
        <p>캐시도 같습니다. <strong>자주 조회되는 데이터를 메모리에 보관</strong>해두면, 매번 데이터베이스까지 가지 않고 빠르게 응답할 수 있습니다.</p>
      </div>

      <h3>왜 캐시가 필요한가?</h3>
      <p>ShopEasy의 상품 목록 페이지를 생각해봅시다:</p>
      <ul>
        <li>사용자 100명이 동시에 상품 목록을 조회</li>
        <li>매번 RDS MySQL에서 같은 쿼리를 실행</li>
        <li>RDS → 디스크 읽기 → 네트워크 전송 → 응답 (수십 ms)</li>
      </ul>

      <p>캐시를 사용하면:</p>
      <ul>
        <li>첫 번째 요청만 RDS에서 가져오고, 결과를 Redis에 저장</li>
        <li>이후 99개 요청은 Redis에서 바로 응답 (1~2 ms)</li>
        <li><strong>RDS 부하 감소 + 응답 속도 향상</strong></li>
      </ul>

      <div class="diagram">
        <div class="diagram-title">캐시 동작 비교</div>
        <div style="margin-bottom:1.5rem;">
          <div style="font-weight:600; margin-bottom:0.5rem;">[캐시 없이]</div>
          <div class="diagram-row">
            <div class="diagram-box user"><div class="box-title">사용자</div></div>
            <div class="diagram-arrow">&rarr;</div>
            <div class="diagram-box compute"><div class="box-title">API 서버</div></div>
            <div class="diagram-arrow">&rarr;</div>
            <div class="diagram-box database"><div class="box-title">RDS</div><div class="box-sub">매 요청마다 DB 조회 (50ms)</div></div>
          </div>
        </div>
        <div>
          <div style="font-weight:600; margin-bottom:0.5rem;">[캐시 있을 때]</div>
          <div class="diagram-row">
            <div class="diagram-box user"><div class="box-title">사용자</div></div>
            <div class="diagram-arrow">&rarr;</div>
            <div class="diagram-box compute"><div class="box-title">API 서버</div></div>
            <div class="diagram-arrow">&rarr;</div>
            <div class="diagram-box cache"><div class="box-title">Redis</div><div class="box-sub">캐시 확인</div></div>
          </div>
          <div class="diagram-row" style="margin-top:0.75rem; justify-content:center;">
            <div class="diagram-col" style="flex:0; align-items:center; margin-right:2rem;">
              <div style="font-weight:600; color:#27ae60;">Hit? Yes</div>
              <div class="diagram-arrow down">&darr;</div>
              <div class="diagram-box cache"><div class="box-title">응답 반환</div><div class="box-sub">1ms</div></div>
            </div>
            <div class="diagram-col" style="flex:0; align-items:center;">
              <div style="font-weight:600; color:#e74c3c;">Hit? No</div>
              <div class="diagram-arrow down">&darr;</div>
              <div class="diagram-box database"><div class="box-title">RDS에서 조회</div><div class="box-sub">50ms</div></div>
              <div class="diagram-arrow down">&darr;</div>
              <div class="diagram-box cache"><div class="box-title">Redis에 저장</div><div class="box-sub">결과를 캐시 후 응답</div></div>
            </div>
          </div>
        </div>
      </div>

      <h3>캐시 히트(Hit)와 캐시 미스(Miss)</h3>
      <table>
        <thead>
          <tr><th>용어</th><th>설명</th><th>결과</th></tr>
        </thead>
        <tbody>
          <tr><td><strong>Cache Hit</strong></td><td>캐시에 데이터가 있음</td><td>빠른 응답 (1~2ms)</td></tr>
          <tr><td><strong>Cache Miss</strong></td><td>캐시에 데이터가 없음</td><td>DB 조회 후 캐시에 저장</td></tr>
          <tr><td><strong>Hit Rate</strong></td><td>캐시 적중률 (Hit / 전체)</td><td>높을수록 좋음 (90% 이상 목표)</td></tr>
        </tbody>
      </table>

      <div class="info-box analogy">
        <div class="info-box-title">비유: 시험 공부</div>
        <p><strong>캐시 히트</strong> = 공부한 내용이 시험에 나옴 → 바로 답을 쓸 수 있음!<br>
        <strong>캐시 미스</strong> = 공부 안 한 내용이 나옴 → 교과서를 찾아봐야 함(느림).<br>
        <strong>캐시 적중률 90%</strong> = 시험 100문제 중 90문제를 이미 알고 있음 → 빠르게 풀 수 있음!</p>
      </div>

      <h3>TTL (Time To Live)</h3>
      <p>캐시된 데이터의 유효 기간입니다. TTL이 지나면 데이터가 자동 삭제됩니다.</p>
      <ul>
        <li><strong>짧은 TTL (30초~1분)</strong>: 자주 변경되는 데이터 (재고 수량, 장바구니)</li>
        <li><strong>중간 TTL (5분~1시간)</strong>: 가끔 변경되는 데이터 (상품 목록, 카테고리)</li>
        <li><strong>긴 TTL (24시간~)</strong>: 거의 안 변하는 데이터 (설정값, 코드표)</li>
      </ul>

      <div class="info-box warning">
        <div class="info-box-title">주의: 캐시 일관성 문제</div>
        <p>데이터베이스의 데이터가 변경되었는데 캐시에는 이전 데이터가 남아 있으면, 사용자가 잘못된 정보를 볼 수 있습니다. 이를 방지하려면:</p>
        <ul>
          <li>적절한 TTL 설정으로 자동 갱신</li>
          <li>데이터 변경 시 관련 캐시를 직접 삭제(무효화)</li>
        </ul>
      </div>
    </section>

    <!-- Section 2: Redis vs Memcached -->
    <section class="content-section" id="redis-vs-memcached">
      <h2>Redis vs Memcached</h2>

      <p>ElastiCache는 두 가지 인메모리 캐시 엔진을 지원합니다.</p>

      <div class="info-box analogy">
        <div class="info-box-title">비유: 스마트폰 vs 계산기</div>
        <p><strong>Redis = 스마트폰</strong>: 전화도 되고, 카메라도 되고, 게임도 되는 다재다능한 도구. 다양한 데이터 타입, 영속성, 복제 지원.</p>
        <p><strong>Memcached = 계산기</strong>: 계산만 가능하지만, 그 한 가지를 정말 잘 함. 단순한 키-값 저장에 특화.</p>
      </div>

      <table>
        <thead>
          <tr><th>특성</th><th>Redis</th><th>Memcached</th></tr>
        </thead>
        <tbody>
          <tr><td>데이터 타입</td><td>String, List, Set, Hash, Sorted Set 등</td><td>String만</td></tr>
          <tr><td>영속성</td><td>지원 (스냅샷, AOF)</td><td>미지원 (재시작 시 데이터 손실)</td></tr>
          <tr><td>복제</td><td>지원 (읽기 복제본)</td><td>미지원</td></tr>
          <tr><td>클러스터</td><td>지원</td><td>지원</td></tr>
          <tr><td>Pub/Sub</td><td>지원</td><td>미지원</td></tr>
          <tr><td>멀티스레드</td><td>싱글스레드 (6.0부터 I/O 멀티스레드)</td><td>멀티스레드</td></tr>
          <tr><td>최대 메모리</td><td>노드당 수백 GB</td><td>노드당 수백 GB</td></tr>
          <tr><td>사용 사례</td><td>세션, 캐싱, 순위표, 실시간 분석</td><td>단순 캐싱</td></tr>
        </tbody>
      </table>

      <div class="info-box tip">
        <div class="info-box-title">권장: Redis를 선택하세요</div>
        <p>특별한 이유가 없다면 <strong>Redis</strong>를 선택하는 것이 좋습니다. 더 많은 기능을 제공하고, 데이터 영속성을 지원하며, AWS에서도 Redis를 더 적극적으로 지원하고 있습니다. 우리 실습에서도 Redis를 사용합니다.</p>
      </div>
    </section>

    <!-- Section 3: Redis 활용 사례 -->
    <section class="content-section" id="redis-use-cases">
      <h2>Redis 활용 사례</h2>

      <h3>1. 세션 스토어 (Session Store)</h3>

      <div class="info-box analogy">
        <div class="info-box-title">비유: 카페 단골 손님 노트</div>
        <p>카페 직원이 단골 손님의 취향을 노트에 적어두면, 다음에 올 때 "아메리카노 한 잔이요!"라고만 해도 됩니다. Redis 세션 스토어는 이 노트와 같습니다. 사용자의 로그인 정보를 Redis에 저장해두면 어떤 서버에 접속하든 로그인 상태가 유지됩니다.</p>
      </div>

      <p>Auto Scaling으로 여러 EC2 인스턴스가 있을 때, 세션을 Redis에 저장하면 어느 서버로 요청이 가도 동일한 세션을 사용할 수 있습니다.</p>

      <h3>2. API 응답 캐싱</h3>
      <p>자주 조회되는 API 응답을 캐시하여 DB 부하를 줄이고 응답 속도를 높입니다.</p>
      <div class="code-block">
        <div class="code-header"><span class="lang">javascript</span><button class="copy-btn">복사</button></div>
        <pre><code>// 상품 목록 API 캐싱 예시 (의사 코드)
async function getProducts(category) {
    const cacheKey = `products:${category}`;

    // 1. Redis에서 캐시 확인
    const cached = await redis.get(cacheKey);
    if (cached) {
        console.log("Cache HIT!");
        return JSON.parse(cached);
    }

    // 2. Cache Miss → DB에서 조회
    console.log("Cache MISS - DB 조회");
    const products = await db.query(
        "SELECT * FROM products WHERE category = ?",
        [category]
    );

    // 3. 결과를 Redis에 캐시 (5분 TTL)
    await redis.set(cacheKey, JSON.stringify(products), 'EX', 300);

    return products;
}</code></pre>
      </div>

      <h3>3. 순위표 (Leaderboard)</h3>
      <p>Redis의 Sorted Set을 사용하면 실시간 순위표를 쉽게 구현할 수 있습니다.</p>
      <div class="code-block">
        <div class="code-header"><span class="lang">bash</span><button class="copy-btn">복사</button></div>
        <pre><code># 인기 상품 순위 (판매량 기준)
ZADD product-ranking 150 "무선 마우스"
ZADD product-ranking 230 "기계식 키보드"
ZADD product-ranking 89 "USB 허브"

# 상위 3개 조회 (높은 점수순)
ZREVRANGE product-ranking 0 2 WITHSCORES
# 결과:
# 1) "기계식 키보드"  230
# 2) "무선 마우스"    150
# 3) "USB 허브"       89</code></pre>
      </div>

      <h3>4. Rate Limiting (요청 제한)</h3>
      <p>특정 사용자의 API 호출 횟수를 제한하여 서비스를 보호합니다.</p>
    </section>

    <!-- Section 4: 클러스터 구성 -->
    <section class="content-section" id="cluster-config">
      <h2>ElastiCache 클러스터 구성</h2>

      <div class="info-box analogy">
        <div class="info-box-title">비유: 편의점 냉장고</div>
        <p>편의점 냉장고 하나만 있으면 고장 시 모든 음료가 따뜻해집니다. 냉장고를 2대(복제본) 준비해두면 하나가 고장나도 다른 냉장고에서 시원한 음료를 제공할 수 있습니다.</p>
      </div>

      <h3>클러스터 모드</h3>
      <table>
        <thead>
          <tr><th>모드</th><th>설명</th><th>적합한 경우</th></tr>
        </thead>
        <tbody>
          <tr><td>클러스터 모드 비활성화</td><td>프라이머리 1개 + 복제본 0~5개</td><td>소규모, 실습 (우리가 사용)</td></tr>
          <tr><td>클러스터 모드 활성화</td><td>여러 샤드로 데이터 분산</td><td>대용량, 고성능 필요</td></tr>
        </tbody>
      </table>

      <h3>노드 타입</h3>
      <table>
        <thead>
          <tr><th>노드 타입</th><th>메모리</th><th>네트워크</th><th>프리티어</th></tr>
        </thead>
        <tbody>
          <tr><td><code>cache.t3.micro</code></td><td>0.5GB</td><td>저~중간</td><td>O (750시간/월)</td></tr>
          <tr><td><code>cache.t3.small</code></td><td>1.37GB</td><td>저~중간</td><td>X</td></tr>
          <tr><td><code>cache.r6g.large</code></td><td>13.07GB</td><td>최대 10Gbps</td><td>X</td></tr>
        </tbody>
      </table>

      <div class="info-box danger">
        <div class="info-box-title">비용 주의: ElastiCache</div>
        <p>ElastiCache는 <strong>프리티어에서 cache.t3.micro 750시간/월</strong>이 무료입니다(처음 12개월). <code>cache.t3.micro</code>만 사용하세요! 더 큰 인스턴스는 시간당 요금이 발생합니다. 실습 후 사용하지 않으면 반드시 삭제하세요.</p>
        <ul>
          <li>cache.t3.micro: 무료 (프리티어)</li>
          <li>cache.t3.small: ~$0.034/시간 (~$25/월)</li>
          <li>cache.r6g.large: ~$0.166/시간 (~$120/월)</li>
        </ul>
      </div>
    </section>

    <!-- Lab Section -->
    <section class="content-section" id="lab">
      <h2>실습</h2>

      <div class="info-box danger">
        <div class="info-box-title">비용 안내</div>
        <p>cache.t3.micro는 프리티어에서 750시간/월 무료입니다. 하지만 프리티어 기간이 지났거나 다른 ElastiCache 인스턴스가 이미 실행 중이면 비용이 발생합니다. <strong>실습이 끝나면 반드시 클러스터를 삭제하세요.</strong></p>
      </div>

      <div class="lab-section">
        <div class="lab-title">실습: ShopEasy에 Redis 캐싱 적용</div>
        <ol class="steps">

          <!-- Step 1 -->
          <li class="step">
            <div class="step-title">서브넷 그룹 생성</div>
            <p>ElastiCache도 RDS처럼 프라이빗 서브넷에 배치합니다.</p>
            <p>AWS 콘솔에서 <strong>ElastiCache</strong> 서비스로 이동합니다.</p>
            <p>왼쪽 메뉴에서 <strong>Subnet groups</strong> > <strong>Create subnet group</strong>을 클릭합니다.</p>
            <ul>
              <li><strong>Name</strong>: <code>shopeasy-cache-subnet-group</code></li>
              <li><strong>Description</strong>: <code>ShopEasy ElastiCache subnet group</code></li>
              <li><strong>VPC</strong>: ShopEasy VPC 선택</li>
              <li><strong>Subnets</strong>: 프라이빗 서브넷 2개 선택 (AZ-a, AZ-c)</li>
            </ul>
            <p><strong>Create</strong>를 클릭합니다.</p>
            <div class="screenshot-placeholder">ElastiCache 서브넷 그룹 생성 화면</div>
          </li>

          <!-- Step 2 -->
          <li class="step">
            <div class="step-title">보안그룹 생성</div>
            <p>EC2 콘솔 > <strong>Security Groups</strong> > <strong>Create security group</strong></p>
            <ul>
              <li><strong>Security group name</strong>: <code>shopeasy-redis-sg</code></li>
              <li><strong>Description</strong>: <code>ShopEasy Redis security group</code></li>
              <li><strong>VPC</strong>: ShopEasy VPC</li>
            </ul>
            <p><strong>Inbound rules</strong>:</p>
            <table>
              <thead><tr><th>Type</th><th>Port</th><th>Source</th><th>Description</th></tr></thead>
              <tbody>
                <tr><td>Custom TCP</td><td>6379</td><td>API 서버 보안그룹</td><td>Redis from API servers</td></tr>
              </tbody>
            </table>
            <p><strong>Create security group</strong>을 클릭합니다.</p>
            <div class="screenshot-placeholder">Redis 보안그룹 생성 - API 서버에서만 6379 접근 허용</div>

            <div class="info-box concept">
              <div class="info-box-title">보안: 최소 접근 원칙</div>
              <p>Redis 보안그룹은 API 서버의 보안그룹에서만 6379 포트 접근을 허용합니다. 인터넷에서 직접 접근할 수 없으므로 보안이 강화됩니다.</p>
            </div>
          </li>

          <!-- Step 3 -->
          <li class="step">
            <div class="step-title">ElastiCache Redis 클러스터 생성</div>
            <p><strong>ElastiCache</strong> 콘솔 > <strong>Redis caches</strong> > <strong>Create Redis cache</strong>를 클릭합니다.</p>

            <h4>Cluster settings</h4>
            <ul>
              <li><strong>Deployment option</strong>: <code>Design your own cache</code> 선택</li>
              <li><strong>Creation method</strong>: <code>Easy create</code> 또는 <code>Cluster cache</code></li>
              <li><strong>Cluster mode</strong>: <code>Disabled</code> (비활성화)</li>
              <li><strong>Name</strong>: <code>shopeasy-redis</code></li>
              <li><strong>Description</strong>: <code>ShopEasy Redis Cache</code></li>
              <li><strong>Engine version</strong>: 최신 7.x 버전 선택</li>
              <li><strong>Port</strong>: <code>6379</code> (기본값)</li>
              <li><strong>Node type</strong>: <code>cache.t3.micro</code> (프리티어!)</li>
              <li><strong>Number of replicas</strong>: <code>0</code> (실습에서는 복제본 없이)</li>
            </ul>

            <h4>Connectivity</h4>
            <ul>
              <li><strong>Subnet group</strong>: <code>shopeasy-cache-subnet-group</code></li>
              <li><strong>Security groups</strong>: <code>shopeasy-redis-sg</code></li>
            </ul>

            <h4>Advanced settings</h4>
            <ul>
              <li><strong>Backup</strong>: 비활성화 (실습에서는 불필요, 비용 절약)</li>
              <li><strong>Maintenance window</strong>: 기본값</li>
            </ul>

            <p><strong>Create</strong>를 클릭합니다.</p>
            <div class="screenshot-placeholder">ElastiCache Redis 클러스터 생성 설정 화면</div>

            <div class="info-box warning">
              <div class="info-box-title">생성 시간</div>
              <p>ElastiCache 클러스터 생성에 5~10분 정도 걸립니다. 상태가 "creating"에서 "available"로 바뀔 때까지 기다립니다.</p>
            </div>
          </li>

          <!-- Step 4 -->
          <li class="step">
            <div class="step-title">Redis 엔드포인트 확인</div>
            <p>클러스터가 생성되면 <strong>Primary endpoint</strong>를 확인합니다.</p>
            <p>예: <code>shopeasy-redis.abc123.0001.apn2.cache.amazonaws.com:6379</code></p>
            <p>이 엔드포인트를 메모합니다. API 서버에서 이 주소로 연결합니다.</p>
            <div class="screenshot-placeholder">ElastiCache Redis 클러스터 엔드포인트 확인</div>
          </li>

          <!-- Step 5 -->
          <li class="step">
            <div class="step-title">EC2에서 redis-cli로 접속 테스트</div>
            <p>API 서버 EC2에 SSH로 접속하여 Redis에 연결 테스트를 합니다.</p>
            <div class="code-block">
              <div class="code-header"><span class="lang">bash</span><button class="copy-btn">복사</button></div>
              <pre><code># redis-cli 설치 (Amazon Linux 2)
sudo amazon-linux-extras install redis6 -y

# 또는 Amazon Linux 2023
sudo dnf install redis6 -y</code></pre>
            </div>

            <div class="code-block">
              <div class="code-header"><span class="lang">bash</span><button class="copy-btn">복사</button></div>
              <pre><code># Redis 접속 테스트
redis-cli -h shopeasy-redis.abc123.0001.apn2.cache.amazonaws.com -p 6379

# 접속 성공하면 다음 명령어 테스트
> PING
PONG

> SET greeting "안녕하세요, ShopEasy!"
OK

> GET greeting
"안녕하세요, ShopEasy!"

> SET product:001 '{"name":"무선 마우스","price":29900}' EX 300
OK

> GET product:001
"{\"name\":\"무선 마우스\",\"price\":29900}"

> TTL product:001
(integer) 297

> INFO memory
# Memory 정보 확인

> EXIT</code></pre>
            </div>
            <div class="screenshot-placeholder">EC2에서 redis-cli로 ElastiCache 접속 테스트</div>
          </li>

          <!-- Step 6 -->
          <li class="step">
            <div class="step-title">API 서버에 Redis 클라이언트 설치</div>
            <p>EC2에 SSH로 접속하여 Node.js Redis 클라이언트를 설치합니다.</p>
            <div class="code-block">
              <div class="code-header"><span class="lang">bash</span><button class="copy-btn">복사</button></div>
              <pre><code>cd /home/ec2-user/shopeasy-api

# ioredis 패키지 설치 (가장 많이 사용되는 Node.js Redis 클라이언트)
npm install ioredis</code></pre>
            </div>
          </li>

          <!-- Step 7 -->
          <li class="step">
            <div class="step-title">API 서버 .env 변경</div>
            <div class="code-block">
              <div class="code-header"><span class="lang">bash</span><button class="copy-btn">복사</button></div>
              <pre><code>sudo nano /home/ec2-user/shopeasy-api/.env</code></pre>
            </div>
            <p>다음 환경변수를 추가합니다:</p>
            <div class="code-block">
              <div class="code-header"><span class="lang">env</span><button class="copy-btn">복사</button></div>
              <pre><code># Redis 캐시 설정
CACHE_TYPE=redis
REDIS_HOST=shopeasy-redis.abc123.0001.apn2.cache.amazonaws.com
REDIS_PORT=6379
CACHE_TTL=300</code></pre>
            </div>
          </li>

          <!-- Step 8 -->
          <li class="step">
            <div class="step-title">API 서버 재시작</div>
            <div class="code-block">
              <div class="code-header"><span class="lang">bash</span><button class="copy-btn">복사</button></div>
              <pre><code># PM2를 사용하는 경우
pm2 restart all
pm2 logs --lines 20

# 로그에서 "Redis connected" 메시지 확인</code></pre>
            </div>
            <div class="screenshot-placeholder">PM2 로그 - Redis 연결 성공 메시지</div>
          </li>

          <!-- Step 9 -->
          <li class="step">
            <div class="step-title">캐시 동작 확인: 상품 목록 조회</div>
            <p>브라우저 또는 curl로 상품 목록 API를 두 번 호출합니다.</p>
            <div class="code-block">
              <div class="code-header"><span class="lang">bash</span><button class="copy-btn">복사</button></div>
              <pre><code># 첫 번째 요청 (Cache Miss - DB에서 조회)
time curl -s https://d1234abcdef.cloudfront.net/api/products | jq '.responseTime'

# 두 번째 요청 (Cache Hit - Redis에서 조회)
time curl -s https://d1234abcdef.cloudfront.net/api/products | jq '.responseTime'</code></pre>
            </div>
            <p>첫 번째 요청보다 두 번째 요청이 훨씬 빠른 것을 확인합니다.</p>

            <div class="info-box tip">
              <div class="info-box-title">성능 차이 예상</div>
              <p>실제 성능 차이는 데이터 양과 쿼리 복잡도에 따라 다르지만, 일반적으로:</p>
              <ul>
                <li><strong>Cache Miss (DB 조회)</strong>: 50~200ms</li>
                <li><strong>Cache Hit (Redis)</strong>: 1~5ms</li>
                <li>약 <strong>10~100배</strong> 빠름!</li>
              </ul>
            </div>
          </li>

          <!-- Step 10 -->
          <li class="step">
            <div class="step-title">redis-cli에서 캐시된 키 확인</div>
            <p>EC2에서 redis-cli로 접속하여 어떤 데이터가 캐시되었는지 확인합니다.</p>
            <div class="code-block">
              <div class="code-header"><span class="lang">bash</span><button class="copy-btn">복사</button></div>
              <pre><code>redis-cli -h shopeasy-redis.abc123.0001.apn2.cache.amazonaws.com -p 6379

# 저장된 모든 키 확인
> KEYS *
1) "products:all"
2) "products:electronics"
3) "product:001"

# 특정 키의 값 확인
> GET products:all
# JSON 형태의 상품 목록 데이터

# 키의 남은 TTL 확인
> TTL products:all
(integer) 245

# 메모리 사용량 확인
> DBSIZE
(integer) 3

> INFO stats
# 캐시 히트/미스 통계 확인
# keyspace_hits: 45
# keyspace_misses: 3

> EXIT</code></pre>
            </div>
            <div class="screenshot-placeholder">redis-cli에서 캐시된 키와 TTL 확인</div>
          </li>

          <!-- Step 11 -->
          <li class="step">
            <div class="step-title">캐시 무효화 테스트</div>
            <p>상품 정보가 변경되었을 때 캐시를 무효화하는 것을 테스트합니다.</p>
            <div class="code-block">
              <div class="code-header"><span class="lang">bash</span><button class="copy-btn">복사</button></div>
              <pre><code>redis-cli -h shopeasy-redis.abc123.0001.apn2.cache.amazonaws.com -p 6379

# 특정 키 삭제 (캐시 무효화)
> DEL products:all
(integer) 1

# 패턴으로 키 확인
> KEYS products:*
1) "products:electronics"

# 전체 캐시 삭제 (주의: 모든 데이터 삭제!)
> FLUSHALL
OK

> EXIT</code></pre>
            </div>
            <p>캐시 삭제 후 다시 API를 호출하면 처음 한 번은 DB에서 조회(느림)하고, 이후는 캐시에서 제공(빠름)됩니다.</p>
          </li>

        </ol>
      </div>

      <div class="info-box concept">
        <div class="info-box-title">정리: ElastiCache 활용 요약</div>
        <ul>
          <li><strong>캐시</strong> - 자주 조회되는 데이터를 메모리에 보관하여 빠르게 응답</li>
          <li><strong>Redis 선택</strong> - 다양한 데이터 타입, 영속성, 복제 지원</li>
          <li><strong>프라이빗 서브넷</strong> - 외부 접근 차단, API 서버에서만 접근</li>
          <li><strong>TTL</strong> - 캐시 유효 기간 설정으로 자동 갱신</li>
          <li><strong>성능 개선</strong> - DB 조회 대비 10~100배 빠른 응답</li>
        </ul>
      </div>

      <div class="info-box danger">
        <div class="info-box-title">실습 후 정리</div>
        <p>ElastiCache는 실행 중인 동안 계속 비용이 발생합니다. 실습이 끝나면 ElastiCache 콘솔에서 클러스터를 <strong>삭제</strong>하세요. 서브넷 그룹과 보안그룹도 정리합니다.</p>
      </div>
    </section>

    <div class="chapter-nav">
      <a href="23-sqs-sns.html" class="prev">이전: SQS & SNS</a>
      <a href="25-cloudwatch.html" class="next">다음: CloudWatch</a>
    </div>
  </main>
</div>

<script src="../assets/js/main.js"></script>
</body>

</html>
